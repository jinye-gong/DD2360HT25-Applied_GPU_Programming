# Assignment 4 Submission Structure

## Submission Requirements

### PDF File

- **Name**: `DD2360HT25_HW4_Group2.pdf`
- **Content**:
  - Each group member's contributions
  - Answers to each exercise

### ZIP File Structure

The zip file should contain code for each programming question in separate folders:

```
assignment1/
├── Q[1]/
│   ├── hw4-convolution.cu
│   ├── batch_test_N.sh
│   ├── plot_histograms.py
│   ├── Makefile
│   └── README.md
├── 
```

## Group Member Contribution

- Shitong Guo: 50%, Q[1], Q[2]
- Jinye Gong: 50% Q[2], Q[3]

## Q1 –1D Convolution

**Questions to answer in the report**

1. Name 3 applications domain where convolution are used?

   **Image & video processing**: blurring, sharpening, edge detection, denoising, feature extraction.

   **Deep learning (CNNs)**: convolution layers for feature extraction in image classification, object detection, segmentation, etc.

   **Signal processing : FIR filtering, echo cancellation, matched filtering, and modeling LTI system responses.

2. Explain in your own words how you design the tiled kernel and how you choose the tile size.

   (1) How to design the tiled kernel:

   The tiled kernel was designed by letting each thread block compute a consecutive “tile” of output elements. Before computing, the block cooperatively loads the needed input segment into **shared memory**, including a small **halo** on both sides (because the mask radius is 2). After a `__syncthreads()`, each thread computes its output using the cached shared-memory values and writes the result to global memory. This reduces redundant global memory reads because neighboring threads reuse the same input data from shared memory.

   

   (2) How to choose the tile size:

3. How many global memory reads and writes are performed in the basic implementation and the tiled implementation, respectively?  

4. Run with your program with N of 1024, 2048, 4096, 8192, 16384. Include the screenshot of your output.

5. Profile your program using the largest N. Report Achieved Occupancy and Shared Memory usage. Analyze your results.
